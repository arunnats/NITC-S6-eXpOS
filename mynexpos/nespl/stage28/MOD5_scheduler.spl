multipush(BP);
// store the current pid's KPTR, PTBR and PTLR values to the process entry table 
// here we store the offset of the kernal stackmultipush(BP);

alias processTablentry R1;
alias newPid R2;
alias newProcessTableEntry R3;
alias otherCorePid R4;

// compute address of the process table entry for current process
processTableEntry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16;

// save the current stack pointer, PTBR & PTLR
[processTableEntry + 12] = SP % 512;
[processTableEntry + 14] = PTBR;
[processTableEntry + 15] = PTLR;

// acquire the scheduler lock
multipush(R1);
R1 = ACQUIRE_SCHED_LOCK;
call ACCESS_CONTROL;
multipop(R1);

newPid = -1;

// if CORE is primary, just call it normaly except dont schedule IDLE 2
if(CORE == PRIMARY_CORE) then
    // get the other cores PID
    otherCorePid = [SYSTEM_STATUS_TABLE + 6];
    
    if ([SYSTEM_STATUS_TABLE + 5] != 0) then
    // if paging process is blocked, schedule IDLE, else start paging
        if ([PROCESS_TABLE + 16*SWAPPER_DAEMON + 4] != WAIT_DISK) then 
            newPid = SWAPPER_DAEMON;
        else
            newPid = IDLE_PROCESS;
        endif;
    endif;

    // if LOGOUT_STATUS=1 and secondary core isnt running IDLE2, schedule IDLE
    if ([SYSTEM_STATUS_TABLE + 7] == 1 && [otherCorePid] != IDLE2_PROCESS) then
        newPid = IDLE_PROCESS;
    endif;
else
    // if CORE is secondary
    // get the other cores PID
    otherCorePid = [SYSTEM_STATUS_TABLE + 1];
    
    // if PAGING_STATUS or LOGOUT_STATUS is set, schedule IDLE2
    if ([SYSTEM_STATUS_TABLE + 5] != 0 || [SYSTEM_STATUS_TABLE + 7] == 1) then
        newPid = IDLE2_PROCESS;
    endif;
endif;

// no process is selected for scheduling, search for a ready or created process
if (newPid == -1) then 
    alias counter R5;
    alias currPid R6;
    currPid = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
    counter = currPid + 1;

    while (counter < MAX_PROC_NUM) do
        processTableEntry = PROCESS_TABLE + counter*16;
        if (counter != otherCorePid && [processTableEntry + 6] == 0 && ([processTableEntry + 4] == READY || [processTableEntry + 4] == CREATED)) then
            // case CORE == PRIMARY_CORE ->make sure the next program isnt a named program
            if (CORE == PRIMARY_CORE && counter != IDLE2_PROCESS && counter != IDLE_PROCESS && counter != SWAPPER_DAEMON) then
                newPid = counter;
                break;
            else
                // case CORE == SECONDARY_CORE ->make sure the next program isnt a named program
                if (CORE == SECONDARY_CORE && counter != IDLE2_PROCESS && counter != IDLE_PROCESS && counter != LOGIN_PROCESS && counter != SHELL_PROCESS && counter != SWAPPER_DAEMON) then
                    newPid = counter;
                    break;
                endif;
            endif;
        endif;
        counter = counter + 1;
    endwhile;

    // if no process was found, search from the beginning of the process table
    if (newPid == -1) then 
        counter = 0;
        while (counter < currPid) do
            processTableEntry = PROCESS_TABLE + counter*16;
            if (counter != otherCorePid && [processTableEntry + 6] == 0 && ([processTableEntry + 4] == READY || [processTableEntry + 4] == CREATED)) then
                // case CORE == PRIMARY_CORE ->make sure the next program isnt a named program
                if (CORE == PRIMARY_CORE && counter != IDLE2_PROCESS && counter != IDLE_PROCESS && counter != SWAPPER_DAEMON) then
                    newPid = counter;
                    break;
                else
                    // case CORE == SECONDARY_CORE ->make sure the next program isnt a named program
                    if (CORE == SECONDARY_CORE && counter != IDLE2_PROCESS && counter != IDLE_PROCESS && counter != LOGIN_PROCESS && counter != SHELL_PROCESS && counter != SWAPPER_DAEMON) then
                        newPid = counter;
                        break;
                    endif;
                endif;
            endif;
            counter = counter + 1;
        endwhile;
    endif;

    // if no suitable process was found, schedule an idle process
    if (newPid == -1) then 
        if (CORE == PRIMARY_CORE) then
            newPid = IDLE_PROCESS;
        else
            newPid = IDLE2_PROCESS;
        endif;
    endif;
endif;

// update process table with the selected process
newProcessTable = PROCESS_TABLE + nextPID * 16;
[SYSTEM_STATUS_TABLE + 5*CORE + 1] = newPid;

// set back PTBR , PTLR
SP =  [newProcessTable + 11] * 512 + [newProcessTable + 12];
PTBR = [newProcessTable + 14];
PTLR = [newProcessTable + 15];

// if the new process was just created, set it to RUNNING and return to user mode
if ([newProcessTableEntry + 4] == CREATED) then
    [newProcessTableEntry + 4] = RUNNING;
    BP = [[newProcessTableEntry + 11]*512];

    // release the lock
    multipush(R1, R2, R3);
    R1 = RELEASE_LOCK;
    R2 = SCHED_LOCK;
    call ACCESS_CONTROL;
    multipop(R1, R2, R3);

    SP = [newProcessTableEntry + 13];
    ireturn;
endif;

// mark the selected process as running
[newProcessTableEntry + 4] = RUNNING;

// release the lock
multipush(R1, R2, R3);
R1 = RELEASE_LOCK;
R2 = SCHED_LOCK;
call ACCESS_CONTROL;
multipop(R1, R2, R3);

multipop(BP);
return;     